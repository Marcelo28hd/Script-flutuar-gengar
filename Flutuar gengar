-- ✅ MODIFICADO: Proteção contra teleporte, bring e fling (reforçada) ativa desde a execução do script
-- ✅ CORRIGIDO: Renasce na última posição válida, reativa flutuar IMEDIATAMENTE ao respawn se estava ativo antes da morte
-- ✅ ADICIONADO: Manipulação automática de flutuar na morte e respawn (desativa na morte, espera respawn, renasce no mesmo lugar, reativa imediatamente se estava ON)
local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local player            = Players.LocalPlayer
local gui               = player:WaitForChild("PlayerGui")

-- Evita múltiplas instâncias
if gui:FindFirstChild("SimpleFloatHUD") then return end

-- Parâmetros
local floating          = false
local wasFloating       = false -- Armazena se flutuar estava ativo antes da morte
local connHeartbeat     = nil
local floatTempo        = 0        -- Tempo para oscilação vertical
local orbitTempo        = 0        -- Tempo para órbita
local amplitude         = 3.0      -- Altura máxima da oscilação (studs) - Preset
local base_freq_factor  = 2.5 * 0.5  -- Fator para oscilação
local baseFloatFrequency= base_freq_factor / amplitude  -- Frequência base da oscilação
local baseOrbitFrequency= 0.5  -- Frequência base da órbita
local speedFactor       = 0.6      -- Fator de velocidade (0.5x a 2.0x) - Preset
local floatFrequency    = baseFloatFrequency * speedFactor  -- Frequência efetiva da oscilação
local orbitFrequency    = baseOrbitFrequency * speedFactor  -- Frequência efetiva da órbita
local orbitRadius       = 6.0      -- Raio da órbita (studs) - Preset
local orbitCenter       = nil      -- Centro dinâmico da órbita
local basePosition      = nil      -- Posição base para oscilação
local pitchOffset       = 245      -- INCLINAÇÃO CORRIGIDA: 245° (persistente)
local defaultSpeed      = 8        -- Velocidade normal
local floatSpeed        = 30       -- Velocidade ao flutuar/voar
local moveSpeed         = defaultSpeed
local lastYaw           = 0        -- Última direção
local lastPosition      = nil      -- Posição antes de flutuar
local flyUp             = false     -- Estado de subida
local flyDown           = false     -- Estado de descida
local flySpeed          = 20       -- Velocidade vertical de voo
local isMobile          = UserInputService.TouchEnabled -- Detecta dispositivo móvel
local lastValidPosition = nil   -- Última posição válida para prevenção de teleporte
local lastValidVelocity = Vector3.new() -- Última velocidade válida para proteção contra fling

-- Conexões
local connHumanoidState = nil
local connRootPartChanged = nil
local connAntiTeleport = nil
local connHumanoidDied = nil
local toggleBtn = nil -- Referência ao botão de toggle para atualizar a HUD
local flyUpBtn, flyDownBtn = nil, nil

-- Função para aplicar rotação persistentemente (usada apenas no modo flutuar)
local function applyPersistentRotation(hrp)
    if not floating then return end
    local rot = CFrame.Angles(0, math.rad(lastYaw), 0) * CFrame.Angles(math.rad(90 + pitchOffset), 0, 0)
    hrp.CFrame = CFrame.new(hrp.Position) * rot
end

-- Função para prevenir teleporte, bring e fling
local function preventTeleportAndFling()
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end

    -- Zera velocidades para prevenir fling
    if hrp.Velocity.Magnitude > 50 or hrp.AssemblyLinearVelocity.Magnitude > 50 then
        hrp.Velocity = Vector3.new()
        hrp.AssemblyLinearVelocity = Vector3.new()
    end

    -- Reverte teleportes para a última posição válida
    if lastValidPosition and (hrp.Position - lastValidPosition).Magnitude > 50 then
        hrp.CFrame = CFrame.new(lastValidPosition)
    end
    lastValidPosition = hrp.Position
    lastValidVelocity = hrp.Velocity
end

-- Inicia a flutuação com movimento, direção, voo livre e órbita circular
local function startFloating()
    if floating then return end
    floating    = true
    wasFloating = true -- Marca que flutuar está ativo
    floatTempo  = 0
    orbitTempo  = 0
    moveSpeed   = floatSpeed

    local char     = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local hrp      = char:WaitForChild("HumanoidRootPart")

    -- Guarda a posição atual antes de começar a flutuar
    lastPosition = hrp.Position
    humanoid.PlatformStand = true
    basePosition = hrp.Position
    orbitCenter  = hrp.Position
    lastValidPosition = hrp.Position

    -- Monitora mudanças no estado do Humanoid para reaplicar inclinação após slap
    if connHumanoidState then
        connHumanoidState:Disconnect()
        connHumanoidState = nil
    end
    connHumanoidState = humanoid.StateChanged:Connect(function(oldState, newState)
        if floating and newState == Enum.HumanoidStateType.Physics then
            task.wait(0.05) -- Pequeno delay para evitar conflito
            applyPersistentRotation(hrp)
            humanoid.PlatformStand = true
        end
    end)

    -- Monitora mudanças no CFrame do RootPart para reaplicar inclinação
    if connRootPartChanged then
        connRootPartChanged:Disconnect()
        connRootPartChanged = nil
    end
    connRootPartChanged = hrp:GetPropertyChangedSignal("CFrame"):Connect(function()
        if floating then
            task.wait() -- Yield para próximo frame
            applyPersistentRotation(hrp)
        end
    end)

    if connHeartbeat then
        connHeartbeat:Disconnect()
        connHeartbeat = nil
    end
    connHeartbeat = RunService.Heartbeat:Connect(function(dt)
        floatTempo = floatTempo + dt
        orbitTempo = orbitTempo + dt

        -- Oscilação vertical
        local yOff = math.sin(floatTempo * 2 * math.pi * floatFrequency) * amplitude

        -- Movimento orbital circular no plano XZ
        local orbitX = math.cos(orbitTempo * 2 * math.pi * orbitFrequency) * orbitRadius
        local orbitZ = math.sin(orbitTempo * 2 * math.pi * orbitFrequency) * orbitRadius

        -- Direção de movimento no plano XZ
        local dir = humanoid.MoveDirection
        if dir.Magnitude > 0.1 then
            lastYaw = math.deg(math.atan2(-dir.X, -dir.Z))
            local moveDelta = Vector3.new(dir.X, 0, dir.Z) * moveSpeed * dt
            basePosition = basePosition + moveDelta
            orbitCenter = orbitCenter + moveDelta
        end

        -- Movimento vertical (voo livre)
        if flyUp then
            basePosition = basePosition + Vector3.new(0, flySpeed * dt, 0)
            orbitCenter = orbitCenter + Vector3.new(0, flySpeed * dt, 0)
        elseif flyDown then
            basePosition = basePosition + Vector3.new(0, -flySpeed * dt, 0)
            orbitCenter = orbitCenter + Vector3.new(0, -flySpeed * dt, 0)
        end

        -- Monta posição com órbita e oscilação
        local targetPos = orbitCenter + Vector3.new(orbitX, yOff, orbitZ)
        
        -- Usa pitchOffset atualizado em TEMPO REAL
        local rot = CFrame.Angles(0, math.rad(lastYaw), 0)
                   * CFrame.Angles(math.rad(90 + pitchOffset), 0, 0)

        -- Aplica a posição e rotação diretamente
        hrp.CFrame = CFrame.new(targetPos) * rot
        lastValidPosition = targetPos -- Atualiza a última posição válida
        
        -- Reaplica inclinação extra para persistência contra anti-slap
        applyPersistentRotation(hrp)
    end)

    -- Atualiza HUD (se existir)
    if toggleBtn then
        toggleBtn.Text = "Flutuar: ON"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        if isMobile and flyUpBtn and flyDownBtn then
            flyUpBtn.Visible = true
            flyDownBtn.Visible = true
        end
    end
end

-- Para a flutuação e restaura postura
local function stopFloating()
    if connHeartbeat then
        connHeartbeat:Disconnect()
        connHeartbeat = nil
    end
    if connHumanoidState then
        connHumanoidState:Disconnect()
        connHumanoidState = nil
    end
    if connRootPartChanged then
        connRootPartChanged:Disconnect()
        connRootPartChanged = nil
    end
    floating    = false
    floatTempo  = 0
    orbitTempo  = 0
    moveSpeed   = defaultSpeed
    flyUp       = false
    flyDown     = false

    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.PlatformStand = false
    end

    -- Atualiza HUD (se existir)
    if toggleBtn then
        toggleBtn.Text = "Flutuar: OFF"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        if isMobile and flyUpBtn and flyDownBtn then
            flyUpBtn.Visible = false
            flyDownBtn.Visible = false
        end
    end
end

-- Teleporta de volta à posição salva
local function teleportBack()
    if not lastPosition then return end
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp  = char:WaitForChild("HumanoidRootPart")
    hrp.Velocity = Vector3.new()
    hrp.AssemblyLinearVelocity = Vector3.new()
    basePosition = lastPosition
    orbitCenter = lastPosition
    hrp.CFrame   = CFrame.new(lastPosition)
    lastValidPosition = lastPosition -- Atualiza a última posição válida
end

-- Função para configurar personagem após spawn
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")

    -- Espera um pouco para o personagem carregar completamente
    task.wait(0.25)

    -- Renasce na última posição válida se existir
    if lastValidPosition then
        pcall(function()
            hrp.CFrame = CFrame.new(lastValidPosition)
        end)
    end
    lastValidPosition = hrp.Position

    -- Monitora morte do personagem
    if connHumanoidDied then
        connHumanoidDied:Disconnect()
        connHumanoidDied = nil
    end
    connHumanoidDied = humanoid.Died:Connect(function()
        -- Salva se estava flutuando e desativa imediatamente para evitar glitches
        wasFloating = floating
        if floating then
            stopFloating() -- Desativa flutuar na morte para não bugar respawn
        end
        -- OBS: aqui não alteramos a variável de UI diretamente além do stopFloating,
        -- pois o setupCharacter ao renascer tratará de reativar imediatamente se necessário.
    end)

    -- Inicia proteção contra teleporte e fling imediatamente
    if connAntiTeleport then
        connAntiTeleport:Disconnect()
        connAntiTeleport = nil
    end
    connAntiTeleport = RunService.Heartbeat:Connect(preventTeleportAndFling)

    -- Se estava flutuando antes da morte, reativa IMEDIATAMENTE quando o personagem estiver pronto
    if wasFloating then
        -- Espera até que o personagem esteja totalmente pronto (humanoid vivo, hrp disponível)
        local attempts = 0
        while attempts < 100 do
            if char and char.Parent and char:FindFirstChild("Humanoid") and char:FindFirstChild("HumanoidRootPart") then
                local h = char:FindFirstChild("Humanoid")
                local r = char:FindFirstChild("HumanoidRootPart")
                if h and r and h.Health > 0 then
                    break
                end
            end
            attempts = attempts + 1
            task.wait(0.05) -- checagem rápida, retorna muito mais rápido do que wait(7)
        end

        -- Garante que flutuar começa com o personagem pronto
        -- Faz um pcall para evitar erros caso algo ainda não esteja 100% pronto
        pcall(function()
            startFloating()
        end)

        -- Ajusta UI caso necessário
        if toggleBtn then
            toggleBtn.Text = "Flutuar: ON"
            toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
            if isMobile and flyUpBtn and flyDownBtn then
                flyUpBtn.Visible = true
                flyDownBtn.Visible = true
            end
        end

        -- Reseta flag de espera (já reativado)
        wasFloating = false
    end
end

-- Conexão para detectar spawn do personagem
player.CharacterAdded:Connect(setupCharacter)

-- Controles de voo para mobile (e PC como fallback)
local function setupFlyControls()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = true
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = true
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = false
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = false
            end
        end
    end)
end

-- ===== Construção da UI =====
local screenGui = Instance.new("ScreenGui", gui)
screenGui.Name        = "SimpleFloatHUD"
screenGui.ResetOnSpawn = false

-- Botão de mostrar/ocultar HUD
local toggleUIBtn = Instance.new("TextButton", screenGui)
toggleUIBtn.Size              = UDim2.new(0, 30, 0, 30)
toggleUIBtn.Position          = UDim2.new(1, -35, 0, 5)
toggleUIBtn.Text              = "×"
toggleUIBtn.Font              = Enum.Font.GothamBold
toggleUIBtn.TextSize          = 18
toggleUIBtn.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
toggleUIBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleUIBtn).CornerRadius = UDim.new(0, 6)

-- Frame principal da HUD
local frame = Instance.new("Frame", screenGui)
frame.Size              = UDim2.new(0, 220, 0, 340)
frame.Position          = UDim2.new(0, 20, 0, 20)
frame.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.1
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

-- Título
local title = Instance.new("TextLabel", frame)
title.Size              = UDim2.new(1, 0, 0, 25)
title.Position          = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text              = "HUD Flutuar e Orbitar"
title.Font              = Enum.Font.GothamBold
title.TextSize          = 18
title.TextColor3        = Color3.new(1, 1, 1)

-- Botão ligar/desligar
toggleBtn = Instance.new("TextButton", frame)
toggleBtn.Size          = UDim2.new(0.6, 0, 0, 30)
toggleBtn.Position      = UDim2.new(0.2, 0, 0, 30)
toggleBtn.Text          = "Flutuar: OFF"
toggleBtn.Font          = Enum.Font.Gotham
toggleBtn.TextSize      = 16
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 6)

-- Label de amplitude
local ampLabel = Instance.new("TextLabel", frame)
ampLabel.Size              = UDim2.new(0.6, 0, 0, 20)
ampLabel.Position          = UDim2.new(0.2, 0, 0, 70)
ampLabel.Text              = "Altura: " .. string.format("%.1f", amplitude)
ampLabel.Font              = Enum.Font.Gotham
ampLabel.TextSize          = 14
ampLabel.TextColor3        = Color3.new(1, 1, 1)
ampLabel.BackgroundTransparency = 1

-- Botões + / - de amplitude
local minusBtn = Instance.new("TextButton", frame)
minusBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusBtn.Position      = UDim2.new(0.05, 0, 0, 90)
minusBtn.Text          = "–"
minusBtn.Font          = Enum.Font.GothamBold
minusBtn.TextSize      = 20
minusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusBtn).CornerRadius = UDim.new(0, 6)

local plusBtn = Instance.new("TextButton", frame)
plusBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusBtn.Position       = UDim2.new(0.75, 0, 0, 90)
plusBtn.Text           = "+"
plusBtn.Font           = Enum.Font.GothamBold
plusBtn.TextSize       = 20
plusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusBtn).CornerRadius = UDim.new(0, 6)

-- Label de inclinação (Eixo X)
local pitchLabel = Instance.new("TextLabel", frame)
pitchLabel.Size          = UDim2.new(0.6, 0, 0, 20)
pitchLabel.Position      = UDim2.new(0.2, 0, 0, 130)
pitchLabel.Text          = "Inclinação: " .. pitchOffset .. "°"
pitchLabel.Font          = Enum.Font.Gotham
pitchLabel.TextSize      = 14
pitchLabel.TextColor3    = Color3.new(1, 1, 1)
pitchLabel.BackgroundTransparency = 1

-- Botões +Y / -Y de inclinação
local minusYBtn = Instance.new("TextButton", frame)
minusYBtn.Size       = UDim2.new(0.2, 0, 0, 25)
minusYBtn.Position   = UDim2.new(0.05, 0, 0, 150)
minusYBtn.Text       = "-Y"
minusYBtn.Font       = Enum.Font.GothamBold
minusYBtn.TextSize   = 18
minusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusYBtn.TextColor3 = Color3.new(1, 1, 1)
Instance.new("UICorner", minusYBtn).CornerRadius = UDim.new(0, 6)

local plusYBtn = Instance.new("TextButton", frame)
plusYBtn.Size        = UDim2.new(0.2, 0, 0, 25)
plusYBtn.Position    = UDim2.new(0.75, 0, 0, 150)
plusYBtn.Text        = "+Y"
plusYBtn.Font        = Enum.Font.GothamBold
plusYBtn.TextSize    = 18
plusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusYBtn.TextColor3  = Color3.new(1, 1, 1)
Instance.new("UICorner", plusYBtn).CornerRadius = UDim.new(0, 6)

-- Label de raio da órbita
local orbitLabel = Instance.new("TextLabel", frame)
orbitLabel.Size          = UDim2.new(0.6, 0, 0, 20)
orbitLabel.Position      = UDim2.new(0.2, 0, 0, 190)
orbitLabel.Text          = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
orbitLabel.Font          = Enum.Font.Gotham
orbitLabel.TextSize      = 14
orbitLabel.TextColor3    = Color3.new(1, 1, 1)
orbitLabel.BackgroundTransparency = 1

-- Botões + / - de raio da órbita
local minusOrbitBtn = Instance.new("TextButton", frame)
minusOrbitBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusOrbitBtn.Position      = UDim2.new(0.05, 0, 0, 210)
minusOrbitBtn.Text          = "–"
minusOrbitBtn.Font          = Enum.Font.GothamBold
minusOrbitBtn.TextSize      = 20
minusOrbitBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusOrbitBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusOrbitBtn).CornerRadius = UDim.new(0, 6)

local plusOrbitBtn = Instance.new("TextButton", frame)
plusOrbitBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusOrbitBtn.Position       = UDim2.new(0.75, 0, 0, 210)
plusOrbitBtn.Text           = "+"
plusOrbitBtn.Font           = Enum.Font.GothamBold
plusOrbitBtn.TextSize       = 20
plusOrbitBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusOrbitBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusOrbitBtn).CornerRadius = UDim.new(0, 6)

-- Label de velocidade
local speedLabel = Instance.new("TextLabel", frame)
speedLabel.Size          = UDim2.new(0.6, 0, 0, 20)
speedLabel.Position      = UDim2.new(0.2, 0, 0, 250)
speedLabel.Text          = "Velocidade: " .. string.format("%.1fx", speedFactor)
speedLabel.Font          = Enum.Font.Gotham
speedLabel.TextSize      = 14
speedLabel.TextColor3    = Color3.new(1, 1, 1)
speedLabel.BackgroundTransparency = 1

-- Botões + / - de velocidade
local minusSpeedBtn = Instance.new("TextButton", frame)
minusSpeedBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusSpeedBtn.Position      = UDim2.new(0.05, 0, 0, 270)
minusSpeedBtn.Text          = "–"
minusSpeedBtn.Font          = Enum.Font.GothamBold
minusSpeedBtn.TextSize      = 20
minusSpeedBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusSpeedBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusSpeedBtn).CornerRadius = UDim.new(0, 6)

local plusSpeedBtn = Instance.new("TextButton", frame)
plusSpeedBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusSpeedBtn.Position       = UDim2.new(0.75, 0, 0, 270)
plusSpeedBtn.Text           = "+"
plusSpeedBtn.Font           = Enum.Font.GothamBold
plusSpeedBtn.TextSize       = 20
plusSpeedBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusSpeedBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusSpeedBtn).CornerRadius = UDim.new(0, 6)

-- Botão "Voltar"
local backBtn = Instance.new("TextButton", frame)
backBtn.Size              = UDim2.new(0.6, 0, 0, 30)
backBtn.Position          = UDim2.new(0.2, 0, 0, 305)
backBtn.Text              = "Voltar"
backBtn.Font              = Enum.Font.Gotham
backBtn.TextSize          = 16
backBtn.BackgroundColor3  = Color3.fromRGB(60, 60, 60)
backBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", backBtn).CornerRadius = UDim.new(0, 6)

-- Botões de voo para mobile
if isMobile then
    flyUpBtn = Instance.new("TextButton", screenGui)
    flyUpBtn.Size              = UDim2.new(0, 60, 0, 60)
    flyUpBtn.Position          = UDim2.new(1, -80, 0.5, -80)
    flyUpBtn.Text              = "↑"
    flyUpBtn.Font              = Enum.Font.GothamBold
    flyUpBtn.TextSize          = 24
    flyUpBtn.BackgroundColor3  = Color3.fromRGB(50, 50, 50)
    flyUpBtn.TextColor3        = Color3.new(1, 1, 1)
    flyUpBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyUpBtn).CornerRadius = UDim.new(0, 10)

    flyDownBtn = Instance.new("TextButton", screenGui)
    flyDownBtn.Size            = UDim2.new(0, 60, 0, 60)
    flyDownBtn.Position        = UDim2.new(1, -80, 0.5, 20)
    flyDownBtn.Text            = "↓"
    flyDownBtn.Font            = Enum.Font.GothamBold
    flyDownBtn.TextSize        = 24
    flyDownBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    flyDownBtn.TextColor3      = Color3.new(1, 1, 1)
    flyDownBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyDownBtn).CornerRadius = UDim.new(0, 10)
    flyUpBtn.Visible = false
    flyDownBtn.Visible = false
end

-- Conexões de botões e lógica de UI
toggleBtn.MouseButton1Click:Connect(function()
    if not floating then
        startFloating()
    else
        stopFloating()
    end
end)

minusBtn.MouseButton1Click:Connect(function()
    amplitude = math.max(amplitude - 0.5, 0.5)
    baseFloatFrequency = base_freq_factor / amplitude
    floatFrequency = baseFloatFrequency * speedFactor
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)
plusBtn.MouseButton1Click:Connect(function()
    amplitude = math.min(amplitude + 0.5, 10)
    baseFloatFrequency = base_freq_factor / amplitude
    floatFrequency = baseFloatFrequency * speedFactor
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)

minusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset - 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)
plusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset + 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)

minusOrbitBtn.MouseButton1Click:Connect(function()
    orbitRadius = math.max(orbitRadius - 0.5, 0.5)
    orbitLabel.Text = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
end)
plusOrbitBtn.MouseButton1Click:Connect(function()
    orbitRadius = math.min(orbitRadius + 0.5, 20)
    orbitLabel.Text = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
end)

minusSpeedBtn.MouseButton1Click:Connect(function()
    speedFactor = math.max(speedFactor - 0.1, 0.5)
    floatFrequency = baseFloatFrequency * speedFactor
    orbitFrequency = baseOrbitFrequency * speedFactor
    speedLabel.Text = "Velocidade: " .. string.format("%.1fx", speedFactor)
end)
plusSpeedBtn.MouseButton1Click:Connect(function()
    speedFactor = math.min(speedFactor + 0.1, 2.0)
    floatFrequency = baseFloatFrequency * speedFactor
    orbitFrequency = baseOrbitFrequency * speedFactor
    speedLabel.Text = "Velocidade: " .. string.format("%.1fx", speedFactor)
end)

backBtn.MouseButton1Click:Connect(teleportBack)
toggleUIBtn.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    toggleUIBtn.Text = frame.Visible and "×" or "☰"
end)

if isMobile then
    flyUpBtn.MouseButton1Down:Connect(function()
        flyUp = true
    end)
    flyUpBtn.MouseButton1Up:Connect(function()
        flyUp = false
    end)
    flyDownBtn.MouseButton1Down:Connect(function()
        flyDown = true
    end)
    flyDownBtn.MouseButton1Up:Connect(function()
        flyDown = false
    end)
else
    setupFlyControls()
end

-- Inicia a proteção imediatamente se o personagem já estiver carregado
if player.Character then
    setupCharacter(player.Character)
end
