-- HUD de Flutuação com Movimento Direcional, Inclinação Persistente 245°, Toggle, Voltar, Voo Livre, Órbita Circular e Controle de Velocidade
-- ✅ CORRIGIDO: Inclinação agora é PERSISTENTE mesmo após "slap" ou anti-slap. Aplicada continuamente no loop e em eventos de reset.
local Players        = game:GetService("Players")
local RunService     = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player         = Players.LocalPlayer
local gui            = player:WaitForChild("PlayerGui")

-- Evita múltiplas instâncias
if gui:FindFirstChild("SimpleFloatHUD") then return end

-- Parâmetros
local floating       = false
local connHeartbeat  = nil
local floatTempo     = 0        -- Tempo para oscilação vertical
local orbitTempo     = 0        -- Tempo para órbita
local amplitude      = 3.0      -- Altura máxima da oscilação (studs) - Preset
local base_freq_factor = 2.5 * 0.5  -- Fator para oscilação
local baseFloatFrequency = base_freq_factor / amplitude  -- Frequência base da oscilação
local baseOrbitFrequency = 0.5  -- Frequência base da órbita
local speedFactor    = 0.6      -- Fator de velocidade (0.5x a 2.0x) - Preset
local floatFrequency = baseFloatFrequency * speedFactor  -- Frequência efetiva da oscilação
local orbitFrequency = baseOrbitFrequency * speedFactor  -- Frequência efetiva da órbita
local orbitRadius    = 6.0      -- Raio da órbita (studs) - Preset
local orbitCenter    = nil      -- Centro dinâmico da órbita
local basePosition   = nil      -- Posição base para oscilação
local pitchOffset    = 245      -- ✅ INCLINAÇÃO CORRIGIDA: 245° (persistente)
local defaultSpeed   = 8        -- Velocidade normal
local floatSpeed     = 30       -- Velocidade ao flutuar/voar
local moveSpeed      = defaultSpeed
local lastYaw        = 0        -- Última direção
local lastPosition   = nil      -- Posição antes de flutuar
local flyUp          = false     -- Estado de subida
local flyDown        = false     -- Estado de descida
local flySpeed       = 20       -- Velocidade vertical de voo
local isMobile       = UserInputService.TouchEnabled -- Detecta dispositivo móvel

-- ✅ NOVA: Conexões para persistência de inclinação
local connHumanoidState = nil
local connRootPartChanged = nil

-- Função para aplicar rotação persistentemente
local function applyPersistentRotation(hrp)
    if not floating then return end
    local rot = CFrame.Angles(0, math.rad(lastYaw), 0) * CFrame.Angles(math.rad(90 + pitchOffset), 0, 0)
    hrp.CFrame = CFrame.new(hrp.Position) * rot
end

-- Inicia a flutuação com movimento, direção, voo livre e órbita circular
local function startFloating()
    if floating then return end
    floating    = true
    floatTempo  = 0
    orbitTempo  = 0
    moveSpeed   = floatSpeed

    local char     = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local hrp      = char:WaitForChild("HumanoidRootPart")

    -- Guarda a posição atual antes de começar a flutuar
    lastPosition = hrp.Position
    humanoid.PlatformStand = true
    basePosition = hrp.Position
    orbitCenter  = hrp.Position

    -- ✅ NOVA: Monitora mudanças no estado do Humanoid para reaplicar inclinação após slap
    connHumanoidState = humanoid.StateChanged:Connect(function(oldState, newState)
        if floating and newState == Enum.HumanoidStateType.Physics then
            task.wait(0.1) -- Pequeno delay para evitar conflito
            applyPersistentRotation(hrp)
            humanoid.PlatformStand = true
        end
    end)

    -- ✅ NOVA: Monitora mudanças no CFrame do RootPart para reaplicar inclinação
    connRootPartChanged = hrp:GetPropertyChangedSignal("CFrame"):Connect(function()
        if floating then
            task.wait() -- Yield para próximo frame
            applyPersistentRotation(hrp)
        end
    end)

    connHeartbeat = RunService.Heartbeat:Connect(function(dt)
        floatTempo = floatTempo + dt
        orbitTempo = orbitTempo + dt

        -- Oscilação vertical
        local yOff = math.sin(floatTempo * 2 * math.pi * floatFrequency) * amplitude

        -- Movimento orbital circular no plano XZ
        local orbitX = math.cos(orbitTempo * 2 * math.pi * orbitFrequency) * orbitRadius
        local orbitZ = math.sin(orbitTempo * 2 * math.pi * orbitFrequency) * orbitRadius

        -- Direção de movimento no plano XZ
        local dir = humanoid.MoveDirection
        if dir.Magnitude > 0.1 then
            lastYaw = math.deg(math.atan2(-dir.X, -dir.Z))
            local moveDelta = Vector3.new(dir.X, 0, dir.Z) * moveSpeed * dt
            basePosition = basePosition + moveDelta
            orbitCenter = orbitCenter + moveDelta
        end

        -- Movimento vertical (voo livre)
        if flyUp then
            basePosition = basePosition + Vector3.new(0, flySpeed * dt, 0)
            orbitCenter = orbitCenter + Vector3.new(0, flySpeed * dt, 0)
        elseif flyDown then
            basePosition = basePosition + Vector3.new(0, -flySpeed * dt, 0)
            orbitCenter = orbitCenter + Vector3.new(0, -flySpeed * dt, 0)
        end

        -- Monta posição com órbita e oscilação
        local targetPos = orbitCenter + Vector3.new(orbitX, yOff, orbitZ)
        hrp.Velocity            = Vector3.new()
        hrp.AssemblyLinearVelocity = Vector3.new()
        
        -- ✅ CORRIGIDO: Usa pitchOffset atualizado em TEMPO REAL
        local rot = CFrame.Angles(0, math.rad(lastYaw), 0)
                   * CFrame.Angles(math.rad(90 + pitchOffset), 0, 0)

        -- Aplica a posição e rotação suavemente
        hrp.CFrame = hrp.CFrame:Lerp(CFrame.new(targetPos) * rot, 0.1)
        
        -- ✅ NOVA: Reaplica inclinação extra para persistência contra anti-slap
        applyPersistentRotation(hrp)
    end)
end

-- Para a flutuação e restaura postura
local function stopFloating()
    if connHeartbeat then
        connHeartbeat:Disconnect()
        connHeartbeat = nil
    end
    if connHumanoidState then
        connHumanoidState:Disconnect()
        connHumanoidState = nil
    end
    if connRootPartChanged then
        connRootPartChanged:Disconnect()
        connRootPartChanged = nil
    end
    floating   = false
    floatTempo = 0
    orbitTempo = 0
    moveSpeed  = defaultSpeed
    flyUp      = false
    flyDown    = false

    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.PlatformStand = false
    end
end

-- Teleporta de volta à posição salva
local function teleportBack()
    if not lastPosition then return end
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp  = char:WaitForChild("HumanoidRootPart")
    hrp.Velocity            = Vector3.new()
    hrp.AssemblyLinearVelocity = Vector3.new()
    basePosition = lastPosition
    orbitCenter = lastPosition
    hrp.CFrame   = CFrame.new(lastPosition)
end

-- Detecta teleporte e atualiza basePosition e orbitCenter
local function onCharacterTeleport()
    local char = player.Character
    if not char then return end
    local hrp = char:WaitForChild("HumanoidRootPart")
    if floating then
        basePosition = hrp.Position
        orbitCenter = hrp.Position
        lastPosition = hrp.Position
        applyPersistentRotation(hrp) -- ✅ NOVA: Reaplica após teleporte
    end
end

-- Conexão para detectar mudanças na posição do personagem (teleporte)
player.CharacterAdded:Connect(function(char)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local lastPos = hrp.Position
    RunService.Heartbeat:Connect(function()
        if (hrp.Position - lastPos).Magnitude > 50 then
            onCharacterTeleport()
        end
        lastPos = hrp.Position
    end)
end)

-- Controles de voo para mobile (e PC como fallback)
local function setupFlyControls()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = true
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = true
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = false
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = false
            end
        end
    end)
end

-- ===== Construção da UI =====
local screenGui = Instance.new("ScreenGui", gui)
screenGui.Name        = "SimpleFloatHUD"
screenGui.ResetOnSpawn = false

-- Botão de mostrar/ocultar HUD
local toggleUIBtn = Instance.new("TextButton", screenGui)
toggleUIBtn.Size              = UDim2.new(0, 30, 0, 30)
toggleUIBtn.Position          = UDim2.new(1, -35, 0, 5)
toggleUIBtn.Text              = "×"
toggleUIBtn.Font              = Enum.Font.GothamBold
toggleUIBtn.TextSize          = 18
toggleUIBtn.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
toggleUIBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleUIBtn).CornerRadius = UDim.new(0, 6)

-- Frame principal da HUD
local frame = Instance.new("Frame", screenGui)
frame.Size              = UDim2.new(0, 220, 0, 340)
frame.Position          = UDim2.new(0, 20, 0, 20)
frame.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.1
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

-- Título
local title = Instance.new("TextLabel", frame)
title.Size              = UDim2.new(1, 0, 0, 25)
title.Position          = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text              = "HUD Flutuar e Orbitar"
title.Font              = Enum.Font.GothamBold
title.TextSize          = 18
title.TextColor3        = Color3.new(1, 1, 1)

-- Botão ligar/desligar
local toggleBtn = Instance.new("TextButton", frame)
toggleBtn.Size          = UDim2.new(0.6, 0, 0, 30)
toggleBtn.Position      = UDim2.new(0.2, 0, 0, 30)
toggleBtn.Text          = "Flutuar: OFF"
toggleBtn.Font          = Enum.Font.Gotham
toggleBtn.TextSize      = 16
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 6)

-- Label de amplitude
local ampLabel = Instance.new("TextLabel", frame)
ampLabel.Size              = UDim2.new(0.6, 0, 0, 20)
ampLabel.Position          = UDim2.new(0.2, 0, 0, 70)
ampLabel.Text              = "Altura: " .. string.format("%.1f", amplitude)
ampLabel.Font              = Enum.Font.Gotham
ampLabel.TextSize          = 14
ampLabel.TextColor3        = Color3.new(1, 1, 1)
ampLabel.BackgroundTransparency = 1

-- Botões + / - de amplitude
local minusBtn = Instance.new("TextButton", frame)
minusBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusBtn.Position      = UDim2.new(0.05, 0, 0, 90)
minusBtn.Text          = "–"
minusBtn.Font          = Enum.Font.GothamBold
minusBtn.TextSize      = 20
minusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusBtn).CornerRadius = UDim.new(0, 6)

local plusBtn = Instance.new("TextButton", frame)
plusBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusBtn.Position       = UDim2.new(0.75, 0, 0, 90)
plusBtn.Text           = "+"
plusBtn.Font           = Enum.Font.GothamBold
plusBtn.TextSize       = 20
plusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusBtn).CornerRadius = UDim.new(0, 6)

-- Label de inclinação (Eixo X)
local pitchLabel = Instance.new("TextLabel", frame)
pitchLabel.Size          = UDim2.new(0.6, 0, 0, 20)
pitchLabel.Position      = UDim2.new(0.2, 0, 0, 130)
pitchLabel.Text          = "Inclinação: " .. pitchOffset .. "°"
pitchLabel.Font          = Enum.Font.Gotham
pitchLabel.TextSize      = 14
pitchLabel.TextColor3    = Color3.new(1, 1, 1)
pitchLabel.BackgroundTransparency = 1

-- Botões +Y / -Y de inclinação
local minusYBtn = Instance.new("TextButton", frame)
minusYBtn.Size       = UDim2.new(0.2, 0, 0, 25)
minusYBtn.Position   = UDim2.new(0.05, 0, 0, 150)
minusYBtn.Text       = "-Y"
minusYBtn.Font       = Enum.Font.GothamBold
minusYBtn.TextSize   = 18
minusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusYBtn.TextColor3 = Color3.new(1, 1, 1)
Instance.new("UICorner", minusYBtn).CornerRadius = UDim.new(0, 6)

local plusYBtn = Instance.new("TextButton", frame)
plusYBtn.Size        = UDim2.new(0.2, 0, 0, 25)
plusYBtn.Position    = UDim2.new(0.75, 0, 0, 150)
plusYBtn.Text        = "+Y"
plusYBtn.Font        = Enum.Font.GothamBold
plusYBtn.TextSize    = 18
plusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusYBtn.TextColor3  = Color3.new(1, 1, 1)
Instance.new("UICorner", plusYBtn).CornerRadius = UDim.new(0, 6)

-- Label de raio da órbita
local orbitLabel = Instance.new("TextLabel", frame)
orbitLabel.Size          = UDim2.new(0.6, 0, 0, 20)
orbitLabel.Position      = UDim2.new(0.2, 0, 0, 190)
orbitLabel.Text          = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
orbitLabel.Font          = Enum.Font.Gotham
orbitLabel.TextSize      = 14
orbitLabel.TextColor3    = Color3.new(1, 1, 1)
orbitLabel.BackgroundTransparency = 1

-- Botões + / - de raio da órbita
local minusOrbitBtn = Instance.new("TextButton", frame)
minusOrbitBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusOrbitBtn.Position      = UDim2.new(0.05, 0, 0, 210)
minusOrbitBtn.Text          = "–"
minusOrbitBtn.Font          = Enum.Font.GothamBold
minusOrbitBtn.TextSize      = 20
minusOrbitBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusOrbitBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusOrbitBtn).CornerRadius = UDim.new(0, 6)

local plusOrbitBtn = Instance.new("TextButton", frame)
plusOrbitBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusOrbitBtn.Position       = UDim2.new(0.75, 0, 0, 210)
plusOrbitBtn.Text           = "+"
plusOrbitBtn.Font           = Enum.Font.GothamBold
plusOrbitBtn.TextSize       = 20
plusOrbitBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusOrbitBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusOrbitBtn).CornerRadius = UDim.new(0, 6)

-- Label de velocidade
local speedLabel = Instance.new("TextLabel", frame)
speedLabel.Size          = UDim2.new(0.6, 0, 0, 20)
speedLabel.Position      = UDim2.new(0.2, 0, 0, 250)
speedLabel.Text          = "Velocidade: " .. string.format("%.1fx", speedFactor)
speedLabel.Font          = Enum.Font.Gotham
speedLabel.TextSize      = 14
speedLabel.TextColor3    = Color3.new(1, 1, 1)
speedLabel.BackgroundTransparency = 1

-- Botões + / - de velocidade
local minusSpeedBtn = Instance.new("TextButton", frame)
minusSpeedBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusSpeedBtn.Position      = UDim2.new(0.05, 0, 0, 270)
minusSpeedBtn.Text          = "–"
minusSpeedBtn.Font          = Enum.Font.GothamBold
minusSpeedBtn.TextSize      = 20
minusSpeedBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusSpeedBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusSpeedBtn).CornerRadius = UDim.new(0, 6)

local plusSpeedBtn = Instance.new("TextButton", frame)
plusSpeedBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusSpeedBtn.Position       = UDim2.new(0.75, 0, 0, 270)
plusSpeedBtn.Text           = "+"
plusSpeedBtn.Font           = Enum.Font.GothamBold
plusSpeedBtn.TextSize       = 20
plusSpeedBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusSpeedBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusSpeedBtn).CornerRadius = UDim.new(0, 6)

-- Botão "Voltar"
local backBtn = Instance.new("TextButton", frame)
backBtn.Size              = UDim2.new(0.6, 0, 0, 30)
backBtn.Position          = UDim2.new(0.2, 0, 0, 305)
backBtn.Text              = "Voltar"
backBtn.Font              = Enum.Font.Gotham
backBtn.TextSize          = 16
backBtn.BackgroundColor3  = Color3.fromRGB(60, 60, 60)
backBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", backBtn).CornerRadius = UDim.new(0, 6)

-- Botões de voo para mobile
local flyUpBtn, flyDownBtn
if isMobile then
    flyUpBtn = Instance.new("TextButton", screenGui)
    flyUpBtn.Size              = UDim2.new(0, 60, 0, 60)
    flyUpBtn.Position          = UDim2.new(1, -80, 0.5, -80)
    flyUpBtn.Text              = "↑"
    flyUpBtn.Font              = Enum.Font.GothamBold
    flyUpBtn.TextSize          = 24
    flyUpBtn.BackgroundColor3  = Color3.fromRGB(50, 50, 50)
    flyUpBtn.TextColor3        = Color3.new(1, 1, 1)
    flyUpBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyUpBtn).CornerRadius = UDim.new(0, 10)

    flyDownBtn = Instance.new("TextButton", screenGui)
    flyDownBtn.Size            = UDim2.new(0, 60, 0, 60)
    flyDownBtn.Position        = UDim2.new(1, -80, 0.5, 20)
    flyDownBtn.Text            = "↓"
    flyDownBtn.Font            = Enum.Font.GothamBold
    flyDownBtn.TextSize        = 24
    flyDownBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    flyDownBtn.TextColor3      = Color3.new(1, 1, 1)
    flyDownBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyDownBtn).CornerRadius = UDim.new(0, 10)
end

-- Conexões
toggleBtn.MouseButton1Click:Connect(function()
    if not floating then
        startFloating()
        toggleBtn.Text             = "Flutuar: ON"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        if isMobile then
            flyUpBtn.Visible = true
            flyDownBtn.Visible = true
        end
    else
        stopFloating()
        toggleBtn.Text             = "Flutuar: OFF"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        if isMobile then
            flyUpBtn.Visible = false
            flyDownBtn.Visible = false
        end
    end
end)

minusBtn.MouseButton1Click:Connect(function()
    amplitude = math.max(amplitude - 0.5, 0.5)
    baseFloatFrequency = base_freq_factor / amplitude
    floatFrequency = baseFloatFrequency * speedFactor
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)
plusBtn.MouseButton1Click:Connect(function()
    amplitude = math.min(amplitude + 0.5, 10)
    baseFloatFrequency = base_freq_factor / amplitude
    floatFrequency = baseFloatFrequency * speedFactor
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)

minusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset - 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)
plusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset + 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)

minusOrbitBtn.MouseButton1Click:Connect(function()
    orbitRadius = math.max(orbitRadius - 0.5, 0.5)
    orbitLabel.Text = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
end)
plusOrbitBtn.MouseButton1Click:Connect(function()
    orbitRadius = math.min(orbitRadius + 0.5, 20)
    orbitLabel.Text = "Raio Órbita: " .. string.format("%.1f", orbitRadius)
end)

minusSpeedBtn.MouseButton1Click:Connect(function()
    speedFactor = math.max(speedFactor - 0.1, 0.5)
    floatFrequency = baseFloatFrequency * speedFactor
    orbitFrequency = baseOrbitFrequency * speedFactor
    speedLabel.Text = "Velocidade: " .. string.format("%.1fx", speedFactor)
end)
plusSpeedBtn.MouseButton1Click:Connect(function()
    speedFactor = math.min(speedFactor + 0.1, 2.0)
    floatFrequency = baseFloatFrequency * speedFactor
    orbitFrequency = baseOrbitFrequency * speedFactor
    speedLabel.Text = "Velocidade: " .. string.format("%.1fx", speedFactor)
end)

backBtn.MouseButton1Click:Connect(teleportBack)
toggleUIBtn.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    toggleUIBtn.Text = frame.Visible and "×" or "☰"
end)

if isMobile then
    flyUpBtn.MouseButton1Down:Connect(function()
        flyUp = true
    end)
    flyUpBtn.MouseButton1Up:Connect(function()
        flyUp = false
    end)
    flyDownBtn.MouseButton1Down:Connect(function()
        flyDown = true
    end)
    flyDownBtn.MouseButton1Up:Connect(function()
        flyDown = false
    end)
    flyUpBtn.Visible = false
    flyDownBtn.Visible = false
else
    setupFlyControls()
end
