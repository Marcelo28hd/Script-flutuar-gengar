-- HUD de Flutuação com Movimento Direcional, Inclinação 250°, Toggle, Voltar e Voo Livre
local Players        = game:GetService("Players")
local RunService     = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local player         = Players.LocalPlayer
local gui            = player:WaitForChild("PlayerGui")

-- Evita múltiplas instâncias
if gui:FindFirstChild("SimpleFloatHUD") then return end

-- Parâmetros
local floating       = false
local connHeartbeat  = nil
local tempo          = 0
local amplitude      = 2.5      -- altura máxima da oscilação (studs) - alterado para 2.5 como referência
local base_freq_factor = 2.5 * 0.5  -- Fator para manter velocidade máxima constante (amp_ref * freq_ref)
local frequency      = base_freq_factor / amplitude  -- frequência ajustada dinamicamente
local basePosition   = nil
local pitchOffset    = 250      -- inclinação inicial (graus em X)
local defaultSpeed   = 8        -- velocidade normal
local floatSpeed     = 30       -- velocidade ao flutuar/voar
local moveSpeed      = defaultSpeed
local lastYaw        = 0        -- lembra última direção
local lastPosition   = nil      -- armazena posição antes de flutuar
local flyUp          = false    -- estado de subida
local flyDown        = false    -- estado de descida
local flySpeed       = 20       -- velocidade vertical de voo
local isMobile       = UserInputService.TouchEnabled -- detecta dispositivo móvel

-- Inicia a flutuação com movimento, direção e voo livre
local function startFloating()
    if floating then return end
    floating    = true
    tempo       = 0
    moveSpeed   = floatSpeed

    local char     = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local hrp      = char:WaitForChild("HumanoidRootPart")

    -- Guarda a posição atual antes de começar a flutuar
    lastPosition = hrp.Position
    humanoid.PlatformStand = true
    basePosition = hrp.Position

    connHeartbeat = RunService.Heartbeat:Connect(function(dt)
        tempo = tempo + dt

        -- Oscilação vertical (flutuação)
        local yOff = math.sin(tempo * 2 * math.pi * frequency) * amplitude

        -- Direção de movimento no plano XZ
        local dir = humanoid.MoveDirection
        if dir.Magnitude > 0.1 then
            -- Calcula yaw corretamente
            lastYaw = math.deg(math.atan2(-dir.X, -dir.Z))
            -- Move no plano XZ
            basePosition = basePosition + Vector3.new(dir.X, 0, dir.Z) * moveSpeed * dt
        end

        -- Movimento vertical (voo livre)
        if flyUp then
            basePosition = basePosition + Vector3.new(0, flySpeed * dt, 0)
        elseif flyDown then
            basePosition = basePosition + Vector3.new(0, -flySpeed * dt, 0)
        end

        -- Monta posição e rotação
        local targetPos = basePosition + Vector3.new(0, yOff, 0)
        hrp.Velocity            = Vector3.new()
        hrp.AssemblyLinearVelocity = Vector3.new()
        local rot = CFrame.Angles(0, math.rad(lastYaw), 0)
                   * CFrame.Angles(math.rad(90 + pitchOffset), 0, 0)

        hrp.CFrame = CFrame.new(targetPos) * rot
    end)
end

-- Para a flutuação e restaura postura
local function stopFloating()
    if connHeartbeat then
        connHeartbeat:Disconnect()
        connHeartbeat = nil
    end
    floating   = false
    tempo      = 0
    moveSpeed  = defaultSpeed
    flyUp      = false
    flyDown    = false

    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        char.Humanoid.PlatformStand = false
    end
end

-- Teleporta de volta à posição salva
local function teleportBack()
    if not lastPosition then return end
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp  = char:WaitForChild("HumanoidRootPart")
    -- Desativa momento antes de setar CFrame
    hrp.Velocity            = Vector3.new()
    hrp.AssemblyLinearVelocity = Vector3.new()
    basePosition = lastPosition
    hrp.CFrame   = CFrame.new(lastPosition)
end

-- Detecta teleporte e atualiza basePosition
local function onCharacterTeleport()
    local char = player.Character
    if not char then return end
    local hrp = char:WaitForChild("HumanoidRootPart")
    if floating then
        basePosition = hrp.Position
        lastPosition = hrp.Position
    end
end

-- Conexão para detectar mudanças na posição do personagem (teleporte)
player.CharacterAdded:Connect(function(char)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local lastPos = hrp.Position
    RunService.Heartbeat:Connect(function()
        if (hrp.Position - lastPos).Magnitude > 50 then -- Detecta teleporte por grande mudança de posição
            onCharacterTeleport()
        end
        lastPos = hrp.Position
    end)
end)

-- Controles de voo para mobile (e PC como fallback)
local function setupFlyControls()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = true
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = true
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gameProcessed)
        if gameProcessed or not floating then return end
        if input.UserInputType == Enum.UserInputType.Keyboard then
            if input.KeyCode == Enum.KeyCode.Space then
                flyUp = false
            elseif input.KeyCode == Enum.KeyCode.LeftControl then
                flyDown = false
            end
        end
    end)
end

-- ===== Construção da UI =====
local screenGui = Instance.new("ScreenGui", gui)
screenGui.Name        = "SimpleFloatHUD"
screenGui.ResetOnSpawn = false

-- Botão de mostrar/ocultar HUD
local toggleUIBtn = Instance.new("TextButton", screenGui)
toggleUIBtn.Size              = UDim2.new(0, 30, 0, 30)
toggleUIBtn.Position          = UDim2.new(1, -35, 0, 5)
toggleUIBtn.Text              = "×"
toggleUIBtn.Font              = Enum.Font.GothamBold
toggleUIBtn.TextSize          = 18
toggleUIBtn.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
toggleUIBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleUIBtn).CornerRadius = UDim.new(0, 6)

-- Frame principal da HUD
local frame = Instance.new("Frame", screenGui)
frame.Size              = UDim2.new(0, 220, 0, 240)
frame.Position          = UDim2.new(0, 20, 0, 20)
frame.BackgroundColor3  = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.1
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

-- Título
local title = Instance.new("TextLabel", frame)
title.Size              = UDim2.new(1, 0, 0, 25)
title.Position          = UDim2.new(0, 0, 0, 0)
title.BackgroundTransparency = 1
title.Text              = "HUD Flutuar"
title.Font              = Enum.Font.GothamBold
title.TextSize          = 18
title.TextColor3        = Color3.new(1, 1, 1)

-- Botão ligar/desligar
local toggleBtn = Instance.new("TextButton", frame)
toggleBtn.Size          = UDim2.new(0.6, 0, 0, 30)
toggleBtn.Position      = UDim2.new(0.2, 0, 0, 30)
toggleBtn.Text          = "Flutuar: OFF"
toggleBtn.Font          = Enum.Font.Gotham
toggleBtn.TextSize      = 16
toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
toggleBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0, 6)

-- Label de amplitude
local ampLabel = Instance.new("TextLabel", frame)
ampLabel.Size              = UDim2.new(0.6, 0, 0, 20)
ampLabel.Position          = UDim2.new(0.2, 0, 0, 70)
ampLabel.Text              = "Altura: " .. string.format("%.1f", amplitude)
ampLabel.Font              = Enum.Font.Gotham
ampLabel.TextSize          = 14
ampLabel.TextColor3        = Color3.new(1, 1, 1)
ampLabel.BackgroundTransparency = 1

-- Botões + / - de amplitude
local minusBtn = Instance.new("TextButton", frame)
minusBtn.Size          = UDim2.new(0.2, 0, 0, 25)
minusBtn.Position      = UDim2.new(0.05, 0, 0, 90)
minusBtn.Text          = "–"
minusBtn.Font          = Enum.Font.GothamBold
minusBtn.TextSize      = 20
minusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusBtn.TextColor3    = Color3.new(1, 1, 1)
Instance.new("UICorner", minusBtn).CornerRadius = UDim.new(0, 6)

local plusBtn = Instance.new("TextButton", frame)
plusBtn.Size           = UDim2.new(0.2, 0, 0, 25)
plusBtn.Position       = UDim2.new(0.75, 0, 0, 90)
plusBtn.Text           = "+"
plusBtn.Font           = Enum.Font.GothamBold
plusBtn.TextSize       = 20
plusBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusBtn.TextColor3     = Color3.new(1, 1, 1)
Instance.new("UICorner", plusBtn).CornerRadius = UDim.new(0, 6)

-- Label de inclinação (Eixo X)
local pitchLabel = Instance.new("TextLabel", frame)
pitchLabel.Size          = UDim2.new(0.6, 0, 0, 20)
pitchLabel.Position      = UDim2.new(0.2, 0, 0, 130)
pitchLabel.Text          = "Inclinação: " .. pitchOffset .. "°"
pitchLabel.Font          = Enum.Font.Gotham
pitchLabel.TextSize      = 14
pitchLabel.TextColor3    = Color3.new(1, 1, 1)
pitchLabel.BackgroundTransparency = 1

-- Botões +Y / -Y de inclinação
local minusYBtn = Instance.new("TextButton", frame)
minusYBtn.Size       = UDim2.new(0.2, 0, 0, 25)
minusYBtn.Position   = UDim2.new(0.05, 0, 0, 150)
minusYBtn.Text       = "-Y"
minusYBtn.Font       = Enum.Font.GothamBold
minusYBtn.TextSize   = 18
minusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
minusYBtn.TextColor3 = Color3.new(1, 1, 1)
Instance.new("UICorner", minusYBtn).CornerRadius = UDim.new(0, 6)

local plusYBtn = Instance.new("TextButton", frame)
plusYBtn.Size        = UDim2.new(0.2, 0, 0, 25)
plusYBtn.Position    = UDim2.new(0.75, 0, 0, 150)
plusYBtn.Text        = "+Y"
plusYBtn.Font        = Enum.Font.GothamBold
plusYBtn.TextSize    = 18
plusYBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
plusYBtn.TextColor3  = Color3.new(1, 1, 1)
Instance.new("UICorner", plusYBtn).CornerRadius = UDim.new(0, 6)

-- Botão "Voltar"
local backBtn = Instance.new("TextButton", frame)
backBtn.Size              = UDim2.new(0.6, 0, 0, 30)
backBtn.Position          = UDim2.new(0.2, 0, 0, 185)
backBtn.Text              = "Voltar"
backBtn.Font              = Enum.Font.Gotham
backBtn.TextSize          = 16
backBtn.BackgroundColor3  = Color3.fromRGB(60, 60, 60)
backBtn.TextColor3        = Color3.new(1, 1, 1)
Instance.new("UICorner", backBtn).CornerRadius = UDim.new(0, 6)

-- Botões de voo para mobile
local flyUpBtn, flyDownBtn
if isMobile then
    flyUpBtn = Instance.new("TextButton", screenGui)
    flyUpBtn.Size              = UDim2.new(0, 60, 0, 60)
    flyUpBtn.Position          = UDim2.new(1, -80, 0.5, -80)
    flyUpBtn.Text              = "↑"
    flyUpBtn.Font              = Enum.Font.GothamBold
    flyUpBtn.TextSize          = 24
    flyUpBtn.BackgroundColor3  = Color3.fromRGB(50, 50, 50)
    flyUpBtn.TextColor3        = Color3.new(1, 1, 1)
    flyUpBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyUpBtn).CornerRadius = UDim.new(0, 10)

    flyDownBtn = Instance.new("TextButton", screenGui)
    flyDownBtn.Size            = UDim2.new(0, 60, 0, 60)
    flyDownBtn.Position        = UDim2.new(1, -80, 0.5, 20)
    flyDownBtn.Text            = "↓"
    flyDownBtn.Font            = Enum.Font.GothamBold
    flyDownBtn.TextSize        = 24
    flyDownBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    flyDownBtn.TextColor3      = Color3.new(1, 1, 1)
    flyDownBtn.BackgroundTransparency = 0.3
    Instance.new("UICorner", flyDownBtn).CornerRadius = UDim.new(0, 10)
end

-- Conexões
toggleBtn.MouseButton1Click:Connect(function()
    if not floating then
        startFloating()
        toggleBtn.Text             = "Flutuar: ON"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
        if isMobile then
            flyUpBtn.Visible = true
            flyDownBtn.Visible = true
        end
    else
        stopFloating()
        toggleBtn.Text             = "Flutuar: OFF"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        if isMobile then
            flyUpBtn.Visible = false
            flyDownBtn.Visible = false
        end
    end
end)

minusBtn.MouseButton1Click:Connect(function()
    amplitude = math.max(amplitude - 0.5, 0.5)
    frequency = base_freq_factor / amplitude
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)
plusBtn.MouseButton1Click:Connect(function()
    amplitude = math.min(amplitude + 0.5, 10)
    frequency = base_freq_factor / amplitude
    ampLabel.Text = "Altura: " .. string.format("%.1f", amplitude)
end)

minusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset - 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)
plusYBtn.MouseButton1Click:Connect(function()
    pitchOffset = (pitchOffset + 5) % 360
    pitchLabel.Text = "Inclinação: " .. pitchOffset .. "°"
end)

backBtn.MouseButton1Click:Connect(teleportBack)
toggleUIBtn.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    toggleUIBtn.Text = frame.Visible and "×" or "☰"
end)

if isMobile then
    flyUpBtn.MouseButton1Down:Connect(function()
        flyUp = true
    end)
    flyUpBtn.MouseButton1Up:Connect(function()
        flyUp = false
    end)
    flyDownBtn.MouseButton1Down:Connect(function()
        flyDown = true
    end)
    flyDownBtn.MouseButton1Up:Connect(function()
        flyDown = false
    end)
    -- Inicialmente ocultar botões até ativar flutuação
    flyUpBtn.Visible = false
    flyDownBtn.Visible = false
else
    setupFlyControls() -- Configura controles para PC
end
